# Teach Yourself Computer Science Notes

## Most value short term

## Why learn computer science?
There are two types of software engineers:
* Those who understand computer science well enough to do challenging, innovative work.
* Those who just get by because they are familiar with high-level tools.

Both call themselves software engineers, and both tend to earn similar salaries in their early careers.
But type 1 engineers progress toward more fulfilling and well-renumerated work over time, whether that is valuable commercial work or breakthrough open-source projects, technical leadership or high-quality individual contributions.
Type 2 engineers typically stay at the surface, learning specific tools and technologies, rather than their underlying foundations, only picking up new skills when the winds of technical fashion change.

The oversupply of Type 2 engineers is starting to reduce their employment opportunities and keep them out of more fulfilling work.
If you are looking to become a Type 1 engineer, learning computer science is the only reliable path.

## Subject guides
### Programming
Work through at least the first three chapters of SICP, reading the material and doing the exercises.
For video lectures the recommended resource is [Brian Harvey's SICP lectures](https://archive.org/details/ucberkeley-webcast-PL3E89002AA9B9879E?sort=titleSorter).

SICP is unique in its ability to alter your fundamental beliefs about computers and programming.
Not everybody will experience this.
Some will hate the book, others won't get past the first few pages.
But the potential reward makes it worth trying.

### Computer Architecture
Computer Architecture is an important first look at computing below the surface of software. 
In our experience, it is the most neglected area among self-taught software engineers.

Favorite book is *Computer Systems: A Programmer's Perspective*, and a typical introductory computer architecture course using the book would cover most of chapter 1 through 6. 

After this *The Elements of Computing Systems*, also known as *Nand2Tetris* is the recommended route.
Read and do the projects of the first six chapters.

Once you feel comfortable with the content of Nand2Tetris, we suggest eighter returning to CS:APP, or considering Patterson and Hennessy's *Computer Organization and Design*.
We suggest following Berkeley's [CS61C course](http://inst.eecs.berkeley.edu/~cs61c/sp15/) "Great Ideas in Computer Architecture" for specific readings.

### Algorithms and Data Structures
Familirity with algorithms and data structures is one of the most empowering aspects of a computer science education.
It also serves as a great place to train one's general problem-solving abilities. 

Favorite book is *The Algorithm Design Manual* by Steven Skiena.
Skiena also provides his lectures online.

For practice, our preferred approach is for students to solve problems on Leetcode.
Solve roughly 100 random Leetcode problems as part of your studies.

Read *How to Solve It* by Polya for an excellent and unique guide to general problem solving: it is as applicable to computer science as it is to mathematics.

### Mathematics for Computer Science
Our suggested starting point for discrete mathematics is the set of [lecture notes](https://cims.nyu.edu/~regev/teaching/discrete_math_fall_2005/dmbook.pdf) by László Lovász.

For a more advanced treatment, we suggest *Mathematics of Computer Science* the book-length lecture notes for the MIT course of the same name.

### Operating Systems
Recommended first read is *Operating Systems: Three Easy Pieces*.

After this, we encourage you to explore design decisions of specific operating systems.
For Linux, we suggest Robert Love's fantastic book *Linux Kernel Development*.

A great way to consolidate your understanding of operating systems is to read the code of a small kernel and add features.
One choice is xv6, a port of Unix V6 to ANSI C and x86, maintained for a course at MIT.

### Computer Networking
Our self-taught students who methodically study networking find that they finally understand terms, concepts and protocols they'd been surrounded by for years.

Favorite book on the topic is *Computer Networking: A Top-Down Approach*.
The small projects and exercises in the book are well worth doing, and we particularly like the "Wireshark labs", which they have provided online.

### Databases
It takes more work to self-learn about database systems than it does with most other topics. 
Given the circumstances, we encourage self-learners to generally avoid textbooks and start with the recordings of CS 186, Joe Hellerstein's databases course at Berkeley, and to progress to reading papers after.

One paper worth mentioning for new students is *Architecture of a Database System*, which uniquely provides a high-level view of how relational database management systems (RDBMS) work.
This will serve as a useful skeleton for further study.

*Readings in Database Systems*, better known as the databases "Red Book", is a collection of papers.

Finally, data modeling is a neglected and poorly taught aspect of working with databases.
Our suggested book on the topic is *Data and Reality: A Timeless Perspective on Perceiving and Managing Information in Our Imprecise World.

### Languages and Compilers
> Don't be a boilerplate programmer. Instead, build tools for users and other programmers. Take historical note of textile and steel industries: do you want to build machines and tools, or do you want to operate those machines?
> Ras Bodik at the start of his compilers course.

Most programmers learn languages, whereas most computer scientists learn about languages.
This gives the computer scientist a distinct advantage over the programmer, even in the domain of programming.
Their knowledge generalizes; they are able to understand the operation of a new language more deeply and quickly than those who have merely learned specific languages.

Our suggested introductory text is the excellent *Crafting Interpreters* by Bob Nystrom.
A more traditional recommendation is *Compilers: Principles, Techniques & Tools*, commonly called "the Dragon Book".


### Distributed Systems
Suggested book for self-study is Martin Kleppmann's *Designing Data-Intensive Applications*.
Far better than a traditional textbook, DDIA is a highly readable book designed for practitioners, which somehow avoids sacrificing depth or rigor.

No matter the choice of textbook or other secondary resources, study of distributed systems absolutely mandates reading papers.
A good list is [here](http://dsrg.pdos.csail.mit.edu/papers/).

